*chisel.txt*
==============================================================================
CHISEL3 Constructs                                               *chisel-help*

*chisel-common-functions*
    .zip
    .find
    .foreach
    .map
    .sliding - Great for creating groups on a sliding line
    .group - Great for taking a list and creating groups from it 
    .forall
    .reduce
    .fold
    .foldRight
    .drop
    .dropWhile
    .linesIterator -> Allows you to iterate over strings that are terminated by \n, \r, \r\n
                      This is helpful when you don't want to iterate over each Char of a String
                      because you actually want to iterate over an entire string
    Seq.tabulate

*chisel-zip*
The zip / zipWithIndex functions are used to create a list/sequence by "zipping"
the values up into a list/sequence of lists/sequences. You can see
that the output of iterating with a foreach loop over the zipped data 
shows that a, b, and c each are an element of each index. 

NOTE: zipWithIndex can be ran on a unique list/sequence to create a list 
of the elements with their index.

>
    object Demo extends App{
      val x : Seq[Int] = Seq(1, 3, 5, 7, 9)
      val y : Seq[Int] = Seq(2, 4, 6, 8, 10) 
      val z : Seq[Int] = Seq(10, 20, 30, 40, 50) 
      x.zip(y).zip(z).foreach {
        case ((a,b),c) => println(s"$a, $b, $c")
      }
    }
    Output: 
    [info] running Demo 
    1, 2, 10
    3, 4, 20
    5, 6, 30
    7, 8, 40
    9, 10, 50
    [success] Total time: 5 s, completed Aug 30, 2021 8:02:38 PM
<

*chisel-map*
The map function takes an input list and allows you to create
another list by performing transforms on the input list. In the example
below you take the list and create a new list with the input sequence
times 2. As a result, the output list has the same number of elements
but with the integer values doubled. 

>
    object Demo extends App{
      val x : Seq[Int] = Seq(1, 3, 5, 7, 9)
      val y = x.map( x => x*2)
      println(y)
    }
    Output: 
    [info] running Demo 
    List(2, 6, 10, 14, 18)
    [success] Total time: 7 s, completed Aug 30, 2021 8:14:12 PM
<

*chisel-call-by-value*
When the return type of something() is sent to the function, it executes through only one
time compared to call by name which executes on the function every time the return value
is accessed. 
>
    def something() = {
      println("calling something")
      1 // return value
    }

    def callByValue(x: Int) = {
      println("x1=" + x)
      println("x2=" + x)
    }

    callByName(something())
    >>>
    "calling something"
    x1=1
    x1=1
    <<<
<


*chisel-call-by-name*
Note that x: => Int is call by name which allows you to pass the result of something
in so that every time the Int 1 is returned, the function is re-evaluated.
>
    def something() = {
      println("calling something")
      1 // return value
    }

    def callByName(x: => Int) = {
      println("x1=" + x)
      println("x2=" + x)
    }

    callByName(something())
    >>>
    "calling something"
    x1=1
    "calling something"
    x1=1
    <<<
<
*chisel-higher-order-function*
Note that the x: () => Int allows you to pass x in as a higher order function. The HOF 
results are computed when the HOF is invoked. 
>
  def printTest(x: () => Int): String = {
    println(x().toString)
    x.toString
  }

  val tmp = printTest(() => 5)
<

*chisel-learning*
 1. Use type aliasing when you want to avoid typing the same type: "type Foo = Seq[(UInt, String)]"
 2. A .map(...) statement on an Option[Seq[Any]] is the same as a None() / Some() match statement
 3. Use case classes instead of traits when users need to extend something to create a parameter list
 4. Option[Seq[...]] can be used but often accomplishes the same as just Seq[...] because you can just
    check if the Seq[...] is empty for the None() case. 
 5. Don't keep falling for the excessive if(...) cases. An empty array returns 0 so there's no need to return 0.
    `if (x.Empty) 0x0 else x * 0x8 == x * 0x8`
    
